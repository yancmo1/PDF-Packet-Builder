diff --git a/.gitignore b/.gitignore
index 16caf95..ebbb804 100644
--- a/.gitignore
+++ b/.gitignore
@@ -79,6 +79,7 @@ Dependencies/
 
 fastlane/report.xml
 fastlane/Preview.html
+fastlane/testflight_changelog.txt
 fastlane/screenshots/**/*.png
 fastlane/test_output
 
diff --git a/LIVING_PROJECT_DOC.md b/LIVING_PROJECT_DOC.md
index ebed6d4..ec9870c 100644
--- a/LIVING_PROJECT_DOC.md
+++ b/LIVING_PROJECT_DOC.md
@@ -1,6 +1,6 @@
 # PDF Packet Builder - Living Project Documentation
 
-**Last Updated:** 2025-12-28  
+**Last Updated:** 2025-12-29  
 **Version:** 1.0  
 **Bundle ID:** `com.yancmo.pdfpacketbuilder`  
 **Team ID:** `9PHS626XUN`
@@ -139,6 +139,13 @@ PDF Packet Builder is an iOS application that automates the process of filling P
 - Provides per-recipient actions:
    - Share (iOS share sheet)
    - Mail (in-app mail composer)
+- Optional Message Template:
+   - User-authored Subject + Body (plain text)
+   - Merge tokens:
+     - System tokens (e.g., `{{recipient_name}}`, `{{date}}`, `{{sender_name}}`)
+     - CSV tokens are generated from CSV headers (normalized to lower_snake_case)
+   - Preview rendered subject/body for a chosen recipient
+   - Batch Export Folder writes per-recipient `Packet.pdf` + `Message.txt` (+ `Summary.csv`)
 - Logs sends only after confirmed delivery actions (share completed, mail sent)
 
 **Generation Process:**
@@ -727,6 +734,13 @@ Pre-configured tasks in `.vscode/tasks.json`:
 - [ ] Sent X / Y progress updates after logging
 - [ ] Share sheet displays
 - [ ] Can save/share generated PDFs
+- [ ] Settings: Sender name/email can be entered and persists across relaunch
+- [ ] Message Template: subject/body can be entered and persists across relaunch
+- [ ] Message Template: preview shows per-recipient rendering with merge tokens
+- [ ] Message Template: unknown tokens are warned (and preserved in output)
+- [ ] Export Folder: creates one subfolder per recipient with `Packet.pdf`
+- [ ] Export Folder: when template enabled, writes `Message.txt` per recipient
+- [ ] Export Folder: writes `Summary.csv` at export root (best-effort)
 - [ ] Share 1 PDF → complete → log appears
 - [ ] Share 1 PDF → cancel → no log
 - [ ] Mail 1 PDF → send → log appears
diff --git a/PDFPacketBuilder.xcodeproj/project.pbxproj b/PDFPacketBuilder.xcodeproj/project.pbxproj
index 3d4e5cd..7b64b14 100644
--- a/PDFPacketBuilder.xcodeproj/project.pbxproj
+++ b/PDFPacketBuilder.xcodeproj/project.pbxproj
@@ -14,6 +14,10 @@
 		46EE1C5ED3E34943AAE3C8D6 /* TemplateView.swift in Sources */ = {isa = PBXBuildFile; fileRef = A467159E23014AF791C235BA /* TemplateView.swift */; };
 		554E2E1412EA4CF19E6AC9D1 /* Recipient.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5ACADE9D507B4EA9B24CAFC9 /* Recipient.swift */; };
 		5DEE8681E1204BCB8A76D073 /* PDFTemplate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 00D87B8696134640B767EED4 /* PDFTemplate.swift */; };
+		C0FFEE0C0FFEE0C0FFEE0C02 /* MessageTemplate.swift in Sources */ = {isa = PBXBuildFile; fileRef = C0FFEE0C0FFEE0C0FFEE0C01 /* MessageTemplate.swift */; };
+		C0FFEE0C0FFEE0C0FFEE0C04 /* MessageTemplateRenderer.swift in Sources */ = {isa = PBXBuildFile; fileRef = C0FFEE0C0FFEE0C0FFEE0C03 /* MessageTemplateRenderer.swift */; };
+		C0FFEE0C0FFEE0C0FFEE0C12 /* HowToUseView.swift in Sources */ = {isa = PBXBuildFile; fileRef = C0FFEE0C0FFEE0C0FFEE0C11 /* HowToUseView.swift */; };
+		C0FFEE0C0FFEE0C0FFEE0C14 /* QuickStartView.swift in Sources */ = {isa = PBXBuildFile; fileRef = C0FFEE0C0FFEE0C0FFEE0C13 /* QuickStartView.swift */; };
 		60A8BA1AF9AF40F19620645F /* AppState.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9F9ADA768E1420F8C6582EC /* AppState.swift */; };
 		66FBC06A51784DD28FBF9F4F /* DocumentPicker.swift in Sources */ = {isa = PBXBuildFile; fileRef = C51E955181164807B5629060 /* DocumentPicker.swift */; };
 		6761DB695CBA4AC5B88279FD /* CSVImporterView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 433575B885F14E1DAD777496 /* CSVImporterView.swift */; };
@@ -42,6 +46,10 @@
 
 /* Begin PBXFileReference section */
 		00D87B8696134640B767EED4 /* PDFTemplate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PDFTemplate.swift; sourceTree = "<group>"; };
+		C0FFEE0C0FFEE0C0FFEE0C01 /* MessageTemplate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MessageTemplate.swift; sourceTree = "<group>"; };
+		C0FFEE0C0FFEE0C0FFEE0C03 /* MessageTemplateRenderer.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MessageTemplateRenderer.swift; sourceTree = "<group>"; };
+		C0FFEE0C0FFEE0C0FFEE0C11 /* HowToUseView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HowToUseView.swift; sourceTree = "<group>"; };
+		C0FFEE0C0FFEE0C0FFEE0C13 /* QuickStartView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = QuickStartView.swift; sourceTree = "<group>"; };
 		078690AC6BA44032B6B7259B /* PDFService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PDFService.swift; sourceTree = "<group>"; };
 		109B03007A5A493ABA92DB74 /* SendLog.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SendLog.swift; sourceTree = "<group>"; };
 		1A2B3C4D5E6F7A8B9C0D1E2F /* MailComposer.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MailComposer.swift; sourceTree = "<group>"; };
@@ -101,6 +109,8 @@
 				22534FB84A4D42A2B8598F83 /* GenerateView.swift */,
 				8E298F13E7504F47A4E0F2E4 /* LogsView.swift */,
 				8C5363D938E745A0A7631D30 /* SettingsView.swift */,
+				C0FFEE0C0FFEE0C0FFEE0C13 /* QuickStartView.swift */,
+				C0FFEE0C0FFEE0C0FFEE0C11 /* HowToUseView.swift */,
 				49E8FD54FEAF48F081D8AC4B /* PurchaseView.swift */,
 				8AD658FA7C1D49A8BD281151 /* ContactsPickerView.swift */,
 				433575B885F14E1DAD777496 /* CSVImporterView.swift */,
@@ -114,6 +124,7 @@
 			children = (
 				F9F9ADA768E1420F8C6582EC /* AppState.swift */,
 				00D87B8696134640B767EED4 /* PDFTemplate.swift */,
+				C0FFEE0C0FFEE0C0FFEE0C01 /* MessageTemplate.swift */,
 				5ACADE9D507B4EA9B24CAFC9 /* Recipient.swift */,
 				109B03007A5A493ABA92DB74 /* SendLog.swift */,
 				8B9D1C2E4D6F4A1BB8C2D3E4 /* CSVImportSnapshot.swift */,
@@ -129,6 +140,7 @@
 				1A2B3C4D5E6F7A8B9C0D1E2F /* MailComposer.swift */,
 				A11C0A9D1E7E4A33B8F6A2D1 /* AutoMapping.swift */,
 				A11C0A9F1E7E4A33B8F6A2D1 /* NameNormalization.swift */,
+				C0FFEE0C0FFEE0C0FFEE0C03 /* MessageTemplateRenderer.swift */,
 			);
 			path = Utils;
 			sourceTree = "<group>";
@@ -264,6 +276,7 @@
 				690B7BF56FE4459A9C633D1B /* PDFPacketBuilderApp.swift in Sources */,
 				60A8BA1AF9AF40F19620645F /* AppState.swift in Sources */,
 				5DEE8681E1204BCB8A76D073 /* PDFTemplate.swift in Sources */,
+				C0FFEE0C0FFEE0C0FFEE0C02 /* MessageTemplate.swift in Sources */,
 				554E2E1412EA4CF19E6AC9D1 /* Recipient.swift in Sources */,
 				BDDB00F92D49418F9C8E1B1E /* SendLog.swift in Sources */,
 				0C2B1C9E8C6E4C9BB2D7C9B2 /* CSVImportSnapshot.swift in Sources */,
@@ -277,6 +290,8 @@
 				F61326E76F954C2D95FFE65F /* GenerateView.swift in Sources */,
 				78529E928E674B83BBA74574 /* LogsView.swift in Sources */,
 				7C0ECE93E38446ADBE728224 /* SettingsView.swift in Sources */,
+				C0FFEE0C0FFEE0C0FFEE0C14 /* QuickStartView.swift in Sources */,
+				C0FFEE0C0FFEE0C0FFEE0C12 /* HowToUseView.swift in Sources */,
 				B94F18C9D41E4BF1ACC2E5EC /* PurchaseView.swift in Sources */,
 				0754A4F3237D47B2A7DEEB3F /* ContactsPickerView.swift in Sources */,
 				6761DB695CBA4AC5B88279FD /* CSVImporterView.swift in Sources */,
@@ -290,6 +305,7 @@
 				9A1B2C3D4E5F6A7B8C9D0E1F /* MailComposer.swift in Sources */,
 				A11C0A9E1E7E4A33B8F6A2D1 /* AutoMapping.swift in Sources */,
 				A11C0AA01E7E4A33B8F6A2D1 /* NameNormalization.swift in Sources */,
+				C0FFEE0C0FFEE0C0FFEE0C04 /* MessageTemplateRenderer.swift in Sources */,
 				BC6CD96707994989AE9DC9E1 /* IAPManager.swift in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
diff --git a/PDFPacketBuilder/Models/AppState.swift b/PDFPacketBuilder/Models/AppState.swift
index a33ca71..2c48b47 100644
--- a/PDFPacketBuilder/Models/AppState.swift
+++ b/PDFPacketBuilder/Models/AppState.swift
@@ -14,6 +14,8 @@ class AppState: ObservableObject {
     @Published var csvImport: CSVImportSnapshot? = nil
     @Published var csvEmailColumn: String? = nil
     @Published var csvDisplayNameColumn: String? = nil
+    @Published var senderName: String = ""
+    @Published var senderEmail: String = ""
     
     private let storageService = StorageService()
     
@@ -34,6 +36,8 @@ class AppState: ObservableObject {
         self.csvImport = storageService.loadCSVImport()
         self.csvEmailColumn = storageService.loadCSVEmailColumn()
         self.csvDisplayNameColumn = storageService.loadCSVDisplayNameColumn()
+        self.senderName = storageService.loadSenderName()
+        self.senderEmail = storageService.loadSenderEmail()
     }
     
     func canAddTemplate() -> Bool {
@@ -85,6 +89,18 @@ class AppState: ObservableObject {
             storageService.saveCSVDisplayNameColumn(trimmed)
         }
     }
+
+    func saveSenderName(_ name: String) {
+        let trimmed = name.trimmingCharacters(in: .whitespacesAndNewlines)
+        senderName = trimmed
+        storageService.saveSenderName(trimmed)
+    }
+
+    func saveSenderEmail(_ email: String) {
+        let trimmed = email.trimmingCharacters(in: .whitespacesAndNewlines)
+        senderEmail = trimmed
+        storageService.saveSenderEmail(trimmed)
+    }
     
     func addSendLog(_ log: SendLog) {
         self.sendLogs.insert(log, at: 0)
diff --git a/PDFPacketBuilder/Models/MessageTemplate.swift b/PDFPacketBuilder/Models/MessageTemplate.swift
new file mode 100644
index 0000000..9ca6469
--- /dev/null
+++ b/PDFPacketBuilder/Models/MessageTemplate.swift
@@ -0,0 +1,38 @@
+import Foundation
+
+struct MessageTemplate: Codable, Hashable {
+    var subject: String
+    var body: String
+    var isEnabled: Bool
+    var lastEdited: Date?
+    /// Optional per-template overrides that bind a token name to a CSV header.
+    /// When empty, CSV-derived tokens default to their matching header.
+    var tokenBindings: [String: String]
+
+    init(subject: String = "", body: String = "", isEnabled: Bool = false, lastEdited: Date? = nil, tokenBindings: [String: String] = [:]) {
+        self.subject = subject
+        self.body = body
+        self.isEnabled = isEnabled
+        self.lastEdited = lastEdited
+        self.tokenBindings = tokenBindings
+    }
+
+    var hasAnyContent: Bool {
+        !subject.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ||
+        !body.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
+    }
+
+    static var emptyDisabled: MessageTemplate {
+        MessageTemplate(subject: "", body: "", isEnabled: false, lastEdited: nil, tokenBindings: [:])
+    }
+
+    static var starterEnabled: MessageTemplate {
+        MessageTemplate(
+            subject: "Permission Slip – {{recipient_name}}",
+            body: "Dear Parent,\n\nPlease see the attached permission slip for {{recipient_name}}.\nFill it out and return it promptly.\n\nThank you,\n{{sender_name}}",
+            isEnabled: true,
+            lastEdited: Date(),
+            tokenBindings: [:]
+        )
+    }
+}
diff --git a/PDFPacketBuilder/Models/PDFTemplate.swift b/PDFPacketBuilder/Models/PDFTemplate.swift
index 04917e3..5340c5d 100644
--- a/PDFPacketBuilder/Models/PDFTemplate.swift
+++ b/PDFPacketBuilder/Models/PDFTemplate.swift
@@ -13,16 +13,50 @@ struct PDFTemplate: Codable, Identifiable {
     var pdfData: Data
     var fields: [PDFField]
     var fieldMappings: [String: String] // fieldName -> recipientProperty
+    var messageTemplate: MessageTemplate
     var createdAt: Date
     
-    init(id: UUID = UUID(), name: String, pdfData: Data, fields: [PDFField] = [], fieldMappings: [String: String] = [:], createdAt: Date = Date()) {
+    init(id: UUID = UUID(), name: String, pdfData: Data, fields: [PDFField] = [], fieldMappings: [String: String] = [:], messageTemplate: MessageTemplate = .emptyDisabled, createdAt: Date = Date()) {
         self.id = id
         self.name = name
         self.pdfData = pdfData
         self.fields = fields
         self.fieldMappings = fieldMappings
+        self.messageTemplate = messageTemplate
         self.createdAt = createdAt
     }
+
+    enum CodingKeys: String, CodingKey {
+        case id
+        case name
+        case pdfData
+        case fields
+        case fieldMappings
+        case messageTemplate
+        case createdAt
+    }
+
+    init(from decoder: Decoder) throws {
+        let container = try decoder.container(keyedBy: CodingKeys.self)
+        self.id = try container.decode(UUID.self, forKey: .id)
+        self.name = try container.decode(String.self, forKey: .name)
+        self.pdfData = try container.decode(Data.self, forKey: .pdfData)
+        self.fields = (try container.decodeIfPresent([PDFField].self, forKey: .fields)) ?? []
+        self.fieldMappings = (try container.decodeIfPresent([String: String].self, forKey: .fieldMappings)) ?? [:]
+        self.messageTemplate = (try container.decodeIfPresent(MessageTemplate.self, forKey: .messageTemplate)) ?? .emptyDisabled
+        self.createdAt = (try container.decodeIfPresent(Date.self, forKey: .createdAt)) ?? Date()
+    }
+
+    func encode(to encoder: Encoder) throws {
+        var container = encoder.container(keyedBy: CodingKeys.self)
+        try container.encode(id, forKey: .id)
+        try container.encode(name, forKey: .name)
+        try container.encode(pdfData, forKey: .pdfData)
+        try container.encode(fields, forKey: .fields)
+        try container.encode(fieldMappings, forKey: .fieldMappings)
+        try container.encode(messageTemplate, forKey: .messageTemplate)
+        try container.encode(createdAt, forKey: .createdAt)
+    }
 }
 
 struct PDFField: Codable, Identifiable {
diff --git a/PDFPacketBuilder/Services/StorageService.swift b/PDFPacketBuilder/Services/StorageService.swift
index dcf02d5..bce0dbf 100644
--- a/PDFPacketBuilder/Services/StorageService.swift
+++ b/PDFPacketBuilder/Services/StorageService.swift
@@ -20,6 +20,8 @@ class StorageService {
     private let csvImportKey = "csvImport"
     private let csvEmailColumnKey = "csvEmailColumn"
     private let csvDisplayNameColumnKey = "csvDisplayNameColumn"
+    private let senderNameKey = "senderName"
+    private let senderEmailKey = "senderEmail"
     
     // MARK: - Template Storage
     
@@ -130,6 +132,36 @@ class StorageService {
         }
         return nil
     }
+
+    // MARK: - Sender Settings
+
+    func saveSenderName(_ name: String) {
+        let trimmed = name.trimmingCharacters(in: .whitespacesAndNewlines)
+        if trimmed.isEmpty {
+            defaults.removeObject(forKey: senderNameKey)
+        } else {
+            defaults.set(trimmed, forKey: senderNameKey)
+        }
+    }
+
+    func loadSenderName() -> String {
+        let value = defaults.string(forKey: senderNameKey) ?? ""
+        return value.trimmingCharacters(in: .whitespacesAndNewlines)
+    }
+
+    func saveSenderEmail(_ email: String) {
+        let trimmed = email.trimmingCharacters(in: .whitespacesAndNewlines)
+        if trimmed.isEmpty {
+            defaults.removeObject(forKey: senderEmailKey)
+        } else {
+            defaults.set(trimmed, forKey: senderEmailKey)
+        }
+    }
+
+    func loadSenderEmail() -> String {
+        let value = defaults.string(forKey: senderEmailKey) ?? ""
+        return value.trimmingCharacters(in: .whitespacesAndNewlines)
+    }
     
     // MARK: - Document Directory Access
     
diff --git a/PDFPacketBuilder/Utils/MailComposer.swift b/PDFPacketBuilder/Utils/MailComposer.swift
index 110b8b4..8e9737d 100644
--- a/PDFPacketBuilder/Utils/MailComposer.swift
+++ b/PDFPacketBuilder/Utils/MailComposer.swift
@@ -9,7 +9,10 @@ import SwiftUI
 import MessageUI
 
 struct MailComposer: UIViewControllerRepresentable {
+    static let mailSimulatorDefaultsKey = "debug_useMailSimulator"
+
     let subject: String
+    let body: String
     let recipient: String
     let pdfData: Data
     let fileName: String
@@ -17,21 +20,38 @@ struct MailComposer: UIViewControllerRepresentable {
 
     @Environment(\.dismiss) private var dismiss
     
-    func makeUIViewController(context: Context) -> MFMailComposeViewController {
+    func makeUIViewController(context: Context) -> UIViewController {
+        if shouldUseMailSimulator {
+            let simulated = SimulatedMailComposerView(
+                subject: subject,
+                messageBody: body,
+                recipient: recipient,
+                fileName: fileName,
+                attachmentBytes: pdfData.count,
+                onComplete: onComplete
+            )
+            return UIHostingController(rootView: simulated)
+        }
+
         let composer = MFMailComposeViewController()
         composer.mailComposeDelegate = context.coordinator
         composer.setSubject(subject)
 
+        let trimmedBody = body.trimmingCharacters(in: .whitespacesAndNewlines)
+        if !trimmedBody.isEmpty {
+            composer.setMessageBody(body, isHTML: false)
+        }
+
         if !recipient.isEmpty {
             composer.setToRecipients([recipient])
         }
-        
+
         composer.addAttachmentData(pdfData, mimeType: "application/pdf", fileName: fileName)
-        
+
         return composer
     }
     
-    func updateUIViewController(_ uiViewController: MFMailComposeViewController, context: Context) {}
+    func updateUIViewController(_ uiViewController: UIViewController, context: Context) {}
     
     func makeCoordinator() -> Coordinator {
         Coordinator(self)
@@ -49,11 +69,106 @@ struct MailComposer: UIViewControllerRepresentable {
             parent.dismiss()
         }
     }
+
+    private var shouldUseMailSimulator: Bool {
+#if DEBUG
+        if MFMailComposeViewController.canSendMail() {
+            return false
+        }
+        return UserDefaults.standard.bool(forKey: Self.mailSimulatorDefaultsKey)
+#else
+        return false
+#endif
+    }
 }
 
+#if DEBUG
+private struct SimulatedMailComposerView: View {
+    let subject: String
+    let messageBody: String
+    let recipient: String
+    let fileName: String
+    let attachmentBytes: Int
+    let onComplete: (MFMailComposeResult, Error?) -> Void
+
+    @Environment(\.dismiss) private var dismiss
+
+    var body: some View {
+        NavigationView {
+            List {
+                Section(header: Text("Message")) {
+                    LabeledContent("To", value: recipient.isEmpty ? "(none)" : recipient)
+                    LabeledContent("Subject", value: subject.isEmpty ? "(none)" : subject)
+                }
+
+                Section(header: Text("Body")) {
+                    Text(messageBody.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? "(empty)" : messageBody)
+                        .font(.body)
+                        .frame(maxWidth: .infinity, alignment: .leading)
+                        .textSelection(.enabled)
+                }
+
+                Section(header: Text("Attachment")) {
+                    LabeledContent("File", value: fileName)
+                    LabeledContent("Size", value: formattedBytes(attachmentBytes))
+                }
+
+                Section {
+                    Button("Send") {
+                        onComplete(.sent, nil)
+                        dismiss()
+                    }
+
+                    Button("Save Draft") {
+                        onComplete(.saved, nil)
+                        dismiss()
+                    }
+
+                    Button("Fail") {
+                        onComplete(.failed, MailSimulatorError())
+                        dismiss()
+                    }
+                    .foregroundColor(.red)
+                }
+            }
+            .navigationTitle("Mail Simulator")
+            .toolbar {
+                ToolbarItem(placement: .cancellationAction) {
+                    Button("Cancel") {
+                        onComplete(.cancelled, nil)
+                        dismiss()
+                    }
+                }
+            }
+        }
+    }
+
+    private func formattedBytes(_ bytes: Int) -> String {
+        let formatter = ByteCountFormatter()
+        formatter.allowedUnits = [.useKB, .useMB]
+        formatter.countStyle = .file
+        return formatter.string(fromByteCount: Int64(max(0, bytes)))
+    }
+}
+
+private struct MailSimulatorError: LocalizedError {
+    var errorDescription: String? {
+        "Simulated mail failure."
+    }
+}
+#endif
+
 // Helper to check if mail is available
 extension MFMailComposeViewController {
     static var isAvailable: Bool {
-        canSendMail()
+        if canSendMail() {
+            return true
+        }
+
+#if DEBUG
+        return UserDefaults.standard.bool(forKey: MailComposer.mailSimulatorDefaultsKey)
+#else
+        return false
+#endif
     }
 }
diff --git a/PDFPacketBuilder/Utils/MessageTemplateRenderer.swift b/PDFPacketBuilder/Utils/MessageTemplateRenderer.swift
new file mode 100644
index 0000000..54871a8
--- /dev/null
+++ b/PDFPacketBuilder/Utils/MessageTemplateRenderer.swift
@@ -0,0 +1,110 @@
+import Foundation
+
+struct MessageTemplateValidation: Hashable {
+    var unknownTokens: Set<String>
+    var unresolvedTokens: Set<String>
+    var requiredFieldIssues: [String]
+
+    static var empty: MessageTemplateValidation {
+        MessageTemplateValidation(unknownTokens: [], unresolvedTokens: [], requiredFieldIssues: [])
+    }
+}
+
+struct MessageTemplateRenderResult: Hashable {
+    var subject: String
+    var body: String
+    var validation: MessageTemplateValidation
+}
+
+struct MessageTemplateRenderer {
+    /// Tokens that do not come from CSV headers.
+    static let systemTokens: Set<String> = [
+        "recipient_name",
+        "recipient_email",
+        "packet_title",
+        "date",
+        "sender_name",
+        "sender_email"
+    ]
+
+    private static let tokenRegex: NSRegularExpression = {
+        // {{token_name}} with optional whitespace inside braces.
+        // Tokens are lower_snake_case in v1.
+        let pattern = #"\{\{\s*([a-z0-9_]+)\s*\}\}"#
+        return (try? NSRegularExpression(pattern: pattern, options: [])) ?? NSRegularExpression()
+    }()
+
+    static func extractTokens(from text: String) -> Set<String> {
+        let ns = text as NSString
+        let matches = tokenRegex.matches(in: text, options: [], range: NSRange(location: 0, length: ns.length))
+        var tokens: Set<String> = []
+        for match in matches {
+            guard match.numberOfRanges >= 2 else { continue }
+            let token = ns.substring(with: match.range(at: 1))
+            if !token.isEmpty {
+                tokens.insert(token)
+            }
+        }
+        return tokens
+    }
+
+    static func validate(tokens: Set<String>, allowedTokens: Set<String>, resolvedValues: [String: String], requiredFieldIssues: [String]) -> MessageTemplateValidation {
+        let unknown = tokens.subtracting(allowedTokens)
+
+        var unresolved: Set<String> = []
+        for token in tokens.intersection(allowedTokens) {
+            let value = resolvedValues[token]?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
+            if value.isEmpty {
+                unresolved.insert(token)
+            }
+        }
+
+        return MessageTemplateValidation(
+            unknownTokens: unknown,
+            unresolvedTokens: unresolved,
+            requiredFieldIssues: requiredFieldIssues
+        )
+    }
+
+    static func render(template: MessageTemplate, allowedTokens: Set<String>, resolvedValues: [String: String], requiredFieldIssues: [String] = []) -> MessageTemplateRenderResult {
+        let subjectTokens = extractTokens(from: template.subject)
+        let bodyTokens = extractTokens(from: template.body)
+        let allTokens = subjectTokens.union(bodyTokens)
+
+        let validation = validate(tokens: allTokens, allowedTokens: allowedTokens, resolvedValues: resolvedValues, requiredFieldIssues: requiredFieldIssues)
+
+        let renderedSubject = renderText(template.subject, allowedTokens: allowedTokens, resolvedValues: resolvedValues)
+        let renderedBody = renderText(template.body, allowedTokens: allowedTokens, resolvedValues: resolvedValues)
+
+        return MessageTemplateRenderResult(subject: renderedSubject, body: renderedBody, validation: validation)
+    }
+
+    static func renderText(_ text: String, allowedTokens: Set<String>, resolvedValues: [String: String]) -> String {
+        let ns = text as NSString
+        let matches = tokenRegex.matches(in: text, options: [], range: NSRange(location: 0, length: ns.length))
+        if matches.isEmpty { return text }
+
+        var result = text
+
+        // Replace from end to start to keep ranges stable.
+        for match in matches.reversed() {
+            guard match.numberOfRanges >= 2 else { continue }
+
+            let tokenRange = match.range(at: 1)
+            let fullRange = match.range(at: 0)
+            guard tokenRange.location != NSNotFound, fullRange.location != NSNotFound else { continue }
+
+            let token = ns.substring(with: tokenRange)
+
+            guard allowedTokens.contains(token) else {
+                // Unknown tokens are preserved as-is.
+                continue
+            }
+
+            let replacement = resolvedValues[token] ?? ""
+            result = (result as NSString).replacingCharacters(in: fullRange, with: replacement)
+        }
+
+        return result
+    }
+}
diff --git a/PDFPacketBuilder/Views/ContentView.swift b/PDFPacketBuilder/Views/ContentView.swift
index 468d6e8..3081f0f 100644
--- a/PDFPacketBuilder/Views/ContentView.swift
+++ b/PDFPacketBuilder/Views/ContentView.swift
@@ -9,6 +9,11 @@ struct ContentView: View {
     @EnvironmentObject var appState: AppState
     @EnvironmentObject var iapManager: IAPManager
     @State private var selectedTab = 0
+
+    @AppStorage("showQuickStartOnLaunch") private var showQuickStartOnLaunch = true
+    @AppStorage("hasSeenQuickStart") private var hasSeenQuickStart = false
+    @State private var showingQuickStart = false
+    @State private var didEvaluateQuickStartThisSession = false
     
     var body: some View {
         TabView(selection: $selectedTab) {
@@ -48,6 +53,24 @@ struct ContentView: View {
                 }
                 .tag(5)
         }
+        .onAppear {
+            guard !didEvaluateQuickStartThisSession else { return }
+            didEvaluateQuickStartThisSession = true
+
+            if !hasSeenQuickStart {
+                showingQuickStart = true
+                return
+            }
+
+            if showQuickStartOnLaunch {
+                showingQuickStart = true
+            }
+        }
+        .sheet(isPresented: $showingQuickStart, onDismiss: {
+            hasSeenQuickStart = true
+        }) {
+            QuickStartView()
+        }
     }
 }
 
diff --git a/PDFPacketBuilder/Views/GenerateView.swift b/PDFPacketBuilder/Views/GenerateView.swift
index 9871df3..cfc7c2c 100644
--- a/PDFPacketBuilder/Views/GenerateView.swift
+++ b/PDFPacketBuilder/Views/GenerateView.swift
@@ -14,6 +14,7 @@ struct GenerateView: View {
     @State private var showingShareSheet = false
     @State private var currentShareItem: ShareItem?
     @State private var currentMailItem: MailItem?
+    @State private var currentExportBundle: ExportBundle?
     @State private var showingPaywall = false
     @State private var showingMailUnavailableAlert = false
     @State private var showingMailFailedAlert = false
@@ -22,14 +23,165 @@ struct GenerateView: View {
     @State private var showingNoRecipientsSelectedAlert = false
     @State private var showingShareErrorAlert = false
     @State private var showingNoEmailForRowAlert = false
+    @State private var showingExportErrorAlert = false
+    @State private var exportErrorMessage: String = ""
 
     @State private var statusFilter: StatusFilter = .all
 
     @State private var selectedRecipientIDs: Set<UUID> = []
     @State private var isRecipientListExpanded = true
+
+    @State private var isMessageTemplateExpanded = false
+    @State private var previewRecipientID: UUID? = nil
+
+    @State private var messageTemplateFocus: MessageTemplateFocus? = nil
+    @State private var messageSubjectSelection: NSRange = NSRange(location: 0, length: 0)
+    @State private var messageBodySelection: NSRange = NSRange(location: 0, length: 0)
+
+    @State private var messageBodyEditorHeight: CGFloat = 220
     
     private let pdfService = PDFService()
 
+    private struct CSVTokenDescriptor: Hashable {
+        var token: String
+        var header: String
+    }
+
+    private enum MessageTemplateFocus: Hashable {
+        case subject
+        case body
+    }
+
+    private struct CursorAwareTextField: UIViewRepresentable {
+        @Binding var text: String
+        @Binding var selection: NSRange
+        var placeholder: String
+        var onBeginEditing: (() -> Void)?
+
+        func makeUIView(context: Context) -> UITextField {
+            let field = UITextField(frame: .zero)
+            field.borderStyle = .roundedRect
+            field.placeholder = placeholder
+            field.autocapitalizationType = .sentences
+            field.autocorrectionType = .default
+            field.addTarget(context.coordinator, action: #selector(Coordinator.textDidChange), for: .editingChanged)
+            field.delegate = context.coordinator
+            return field
+        }
+
+        func updateUIView(_ uiView: UITextField, context: Context) {
+            if uiView.text != text {
+                uiView.text = text
+            }
+
+            // Apply selection when this field is currently focused.
+            guard uiView.isFirstResponder else { return }
+            let clamped = clamp(range: selection, in: text)
+            if let start = uiView.position(from: uiView.beginningOfDocument, offset: clamped.location),
+               let end = uiView.position(from: start, offset: clamped.length),
+               let range = uiView.textRange(from: start, to: end) {
+                uiView.selectedTextRange = range
+            }
+        }
+
+        func makeCoordinator() -> Coordinator {
+            Coordinator(self)
+        }
+
+        final class Coordinator: NSObject, UITextFieldDelegate {
+            private let parent: CursorAwareTextField
+
+            init(_ parent: CursorAwareTextField) {
+                self.parent = parent
+            }
+
+            func textFieldDidBeginEditing(_ textField: UITextField) {
+                parent.onBeginEditing?()
+                updateSelection(from: textField)
+            }
+
+            func textFieldDidChangeSelection(_ textField: UITextField) {
+                updateSelection(from: textField)
+            }
+
+            @objc func textDidChange(_ textField: UITextField) {
+                parent.text = textField.text ?? ""
+                updateSelection(from: textField)
+            }
+
+            private func updateSelection(from textField: UITextField) {
+                guard let range = textField.selectedTextRange else { return }
+                let start = textField.offset(from: textField.beginningOfDocument, to: range.start)
+                let end = textField.offset(from: textField.beginningOfDocument, to: range.end)
+                parent.selection = NSRange(location: max(0, start), length: max(0, end - start))
+            }
+        }
+    }
+
+    private struct CursorAwareTextView: UIViewRepresentable {
+        @Binding var text: String
+        @Binding var selection: NSRange
+        var onBeginEditing: (() -> Void)?
+
+        func makeUIView(context: Context) -> UITextView {
+            let view = UITextView(frame: .zero)
+            view.isScrollEnabled = true
+            view.backgroundColor = .systemBackground
+            view.font = UIFont.preferredFont(forTextStyle: .body)
+            view.delegate = context.coordinator
+            view.textContainerInset = UIEdgeInsets(top: 8, left: 4, bottom: 8, right: 4)
+            view.layer.cornerRadius = 8
+            view.layer.masksToBounds = true
+            return view
+        }
+
+        func updateUIView(_ uiView: UITextView, context: Context) {
+            if uiView.text != text {
+                uiView.text = text
+            }
+
+            // Apply selection when this view is currently focused.
+            guard uiView.isFirstResponder else { return }
+            let clamped = clamp(range: selection, in: text)
+            if uiView.selectedRange != clamped {
+                uiView.selectedRange = clamped
+            }
+        }
+
+        func makeCoordinator() -> Coordinator {
+            Coordinator(self)
+        }
+
+        final class Coordinator: NSObject, UITextViewDelegate {
+            private let parent: CursorAwareTextView
+
+            init(_ parent: CursorAwareTextView) {
+                self.parent = parent
+            }
+
+            func textViewDidBeginEditing(_ textView: UITextView) {
+                parent.onBeginEditing?()
+                parent.selection = textView.selectedRange
+            }
+
+            func textViewDidChange(_ textView: UITextView) {
+                parent.text = textView.text
+            }
+
+            func textViewDidChangeSelection(_ textView: UITextView) {
+                parent.selection = textView.selectedRange
+            }
+        }
+    }
+
+    private static func clamp(range: NSRange, in text: String) -> NSRange {
+        let length = (text as NSString).length
+        let loc = min(max(0, range.location), length)
+        let maxLen = max(0, length - loc)
+        let len = min(max(0, range.length), maxLen)
+        return NSRange(location: loc, length: len)
+    }
+
     private enum StatusFilter: String, CaseIterable, Identifiable {
         case all = "All"
         case unsent = "Unsent"
@@ -167,6 +319,8 @@ struct GenerateView: View {
                             .padding()
                             .background(Color(.systemGray6))
                             .cornerRadius(10)
+
+                            messageTemplateSection()
                             
                             Button(action: attemptGenerate) {
                                 Label("Generate PDFs", systemImage: "doc.on.doc")
@@ -255,6 +409,23 @@ struct GenerateView: View {
                                         .background(Color(.systemGray6))
                                         .cornerRadius(8)
                                     }
+
+                                    Button(action: exportGeneratedBundle) {
+                                        Label("Export Folder", systemImage: "folder")
+                                            .frame(maxWidth: .infinity)
+                                            .padding()
+                                            .background(Color(.systemGray5))
+                                            .foregroundColor(.primary)
+                                            .cornerRadius(10)
+                                    }
+                                    .disabled(isGenerating || generatedPDFs.isEmpty)
+
+                                    if currentMessageTemplate().isEnabled && currentMessageTemplate().hasAnyContent {
+                                        Text("Export includes one Message.txt per recipient.")
+                                            .font(.footnote)
+                                            .foregroundColor(.secondary)
+                                            .frame(maxWidth: .infinity, alignment: .leading)
+                                    }
                                 }
                             }
                         }
@@ -305,9 +476,13 @@ struct GenerateView: View {
                     }
                 }
             }
+            .sheet(item: $currentExportBundle) { bundle in
+                ShareSheet(items: [bundle.url])
+            }
             .sheet(item: $currentMailItem) { mailItem in
                 MailComposer(
-                    subject: "\(mailItem.templateName) PDF",
+                    subject: mailItem.subject,
+                    body: mailItem.body,
                     recipient: mailItem.recipientEmail,
                     pdfData: mailItem.pdfData,
                     fileName: mailItem.fileName
@@ -360,9 +535,527 @@ struct GenerateView: View {
             } message: {
                 Text("We could not prepare the PDF for sharing. Please try again.")
             }
+            .alert("Export failed", isPresented: $showingExportErrorAlert) {
+                Button("OK", role: .cancel) { }
+            } message: {
+                Text(exportErrorMessage)
+            }
         }
     }
 
+    private func messageTemplateSection() -> some View {
+        let template = currentMessageTemplate()
+        let hasCSV = appState.csvImport != nil
+        let headers = appState.csvImport?.headers ?? []
+
+        let csvTokens = csvTokenCatalog(headers: headers)
+        let csvTokenSet = Set(csvTokens.map { $0.token })
+        let allowedTokens = MessageTemplateRenderer.systemTokens.union(csvTokenSet)
+
+        let previewRecipient = previewRecipientForTemplate()
+        let resolvedValues = previewRecipient.map { resolvedMessageTokenValues(for: $0, messageTemplate: template, csvTokens: csvTokens) } ?? [:]
+        let referencedTokens = MessageTemplateRenderer.extractTokens(from: template.subject)
+            .union(MessageTemplateRenderer.extractTokens(from: template.body))
+        let requiredIssues = requiredMessageTemplateIssues(
+            referencedTokens: referencedTokens,
+            hasCSV: hasCSV,
+            headers: headers,
+            csvTokenSet: csvTokenSet,
+            messageTemplate: template
+        )
+        let renderResult = MessageTemplateRenderer.render(
+            template: template,
+            allowedTokens: allowedTokens,
+            resolvedValues: resolvedValues,
+            requiredFieldIssues: requiredIssues
+        )
+
+        return VStack(alignment: .leading, spacing: 10) {
+            HStack {
+                Text("Message Template")
+                    .font(.headline)
+                Spacer()
+                Button {
+                    isMessageTemplateExpanded.toggle()
+                } label: {
+                    HStack(spacing: 4) {
+                        Text(isMessageTemplateExpanded ? "Hide" : "Show")
+                        Image(systemName: isMessageTemplateExpanded ? "chevron.up" : "chevron.down")
+                            .font(.caption)
+                    }
+                }
+                .font(.subheadline)
+            }
+
+            if isMessageTemplateExpanded {
+                Toggle(
+                    "Enable message template",
+                    isOn: Binding(
+                        get: { currentMessageTemplate().isEnabled },
+                        set: { newValue in
+                            updateMessageTemplate { mt in
+                                mt.isEnabled = newValue
+                                mt.lastEdited = Date()
+                            }
+                        }
+                    )
+                )
+
+                VStack(alignment: .leading, spacing: 6) {
+                    Text("Subject")
+                        .font(.caption)
+                        .foregroundColor(.secondary)
+                    CursorAwareTextField(
+                        text: Binding(
+                            get: { currentMessageTemplate().subject },
+                            set: { newValue in
+                                updateMessageTemplate { mt in
+                                    mt.subject = newValue
+                                    mt.lastEdited = Date()
+                                    syncTemplateEnabledState(&mt)
+                                }
+                            }
+                        ),
+                        selection: $messageSubjectSelection,
+                        placeholder: "Subject",
+                        onBeginEditing: {
+                            messageTemplateFocus = .subject
+                        }
+                    )
+                }
+
+                VStack(alignment: .leading, spacing: 6) {
+                    Text("Body")
+                        .font(.caption)
+                        .foregroundColor(.secondary)
+
+                    ZStack(alignment: .bottomTrailing) {
+                        CursorAwareTextView(
+                            text: Binding(
+                                get: { currentMessageTemplate().body },
+                                set: { newValue in
+                                    updateMessageTemplate { mt in
+                                        mt.body = newValue
+                                        mt.lastEdited = Date()
+                                        syncTemplateEnabledState(&mt)
+                                    }
+                                }
+                            ),
+                            selection: $messageBodySelection,
+                            onBeginEditing: {
+                                messageTemplateFocus = .body
+                            }
+                        )
+                        .frame(height: max(120, messageBodyEditorHeight))
+                        .overlay(
+                            RoundedRectangle(cornerRadius: 8)
+                                .stroke(Color(.systemGray4), lineWidth: 1)
+                        )
+
+                        Image(systemName: "arrow.up.left.and.arrow.down.right")
+                            .font(.system(size: 13, weight: .semibold))
+                            .foregroundColor(.secondary)
+                            .padding(10)
+                            .background(Color(.systemGray6).opacity(0.9))
+                            .clipShape(RoundedRectangle(cornerRadius: 8))
+                            .padding(8)
+                            .contentShape(Rectangle())
+                            .accessibilityLabel("Resize message body")
+                            .gesture(
+                                DragGesture(minimumDistance: 2)
+                                    .onChanged { value in
+                                        let proposed = messageBodyEditorHeight + value.translation.height
+                                        messageBodyEditorHeight = min(max(120, proposed), 600)
+                                    }
+                            )
+                    }
+                }
+
+                HStack {
+                    Menu {
+                        if hasCSV {
+                            let sortedCSV = csvTokens.sorted { lhs, rhs in
+                                if lhs.token == rhs.token { return lhs.header < rhs.header }
+                                return lhs.token < rhs.token
+                            }
+                            ForEach(sortedCSV, id: \.self) { item in
+                                Button("{{\(item.token)}} (\(item.header))") {
+                                    insertToken(item.token)
+                                }
+                            }
+
+                            if !sortedCSV.isEmpty {
+                                Divider()
+                            }
+                        }
+
+                        ForEach(Array(MessageTemplateRenderer.systemTokens).sorted(), id: \.self) { token in
+                            Button("{{\(token)}}") {
+                                insertToken(token)
+                            }
+                        }
+                    } label: {
+                        Label("Insert Token", systemImage: "curlybraces")
+                    }
+
+                    Spacer()
+
+                    Button("Use Starter") {
+                        updateMessageTemplate { mt in
+                            mt = .starterEnabled
+                        }
+                    }
+
+                    Button("Clear") {
+                        updateMessageTemplate { mt in
+                            mt = .emptyDisabled
+                        }
+                    }
+                }
+                .font(.subheadline)
+
+                VStack(alignment: .leading, spacing: 10) {
+                    HStack {
+                        Text("Preview")
+                            .font(.subheadline)
+                        Spacer()
+
+                        Menu {
+                            Button("Use first selected") { previewRecipientID = nil }
+                            Divider()
+
+                            ForEach(selectedRecipients, id: \.id) { recipient in
+                                Button(displayName(for: recipient)) {
+                                    previewRecipientID = recipient.id
+                                }
+                            }
+                        } label: {
+                            let label = previewRecipient.map { displayName(for: $0) } ?? "(none)"
+                            Label(label, systemImage: "eye")
+                                .lineLimit(1)
+                        }
+                        .disabled(selectedRecipients.isEmpty)
+                    }
+
+                    VStack(alignment: .leading, spacing: 6) {
+                        Text("Subject: \(renderResult.subject)")
+                            .font(.callout)
+                            .frame(maxWidth: .infinity, alignment: .leading)
+
+                        Text(renderResult.body)
+                            .font(.callout)
+                            .frame(maxWidth: .infinity, alignment: .leading)
+                    }
+                    .padding()
+                    .background(Color(.systemGray5))
+                    .cornerRadius(10)
+
+                    if !renderResult.validation.requiredFieldIssues.isEmpty {
+                        warningBlock(title: "Missing mappings", lines: renderResult.validation.requiredFieldIssues)
+                    }
+
+                    if !renderResult.validation.unknownTokens.isEmpty {
+                        warningBlock(
+                            title: "Unknown tokens",
+                            lines: [renderResult.validation.unknownTokens.sorted().joined(separator: ", ")]
+                        )
+                    }
+
+                    if !renderResult.validation.unresolvedTokens.isEmpty {
+                        warningBlock(
+                            title: "Blank for preview recipient",
+                            lines: [renderResult.validation.unresolvedTokens.sorted().joined(separator: ", ")]
+                        )
+                    }
+                }
+            } else if template.hasAnyContent {
+                let status = template.isEnabled ? "Enabled" : "Disabled"
+                Text(status)
+                    .font(.footnote)
+                    .foregroundColor(.secondary)
+            } else {
+                Text("Optional. Add a Subject and Body with tokens like {{recipient_name}} or tokens derived from your CSV headers.")
+                    .font(.footnote)
+                    .foregroundColor(.secondary)
+            }
+        }
+        .padding()
+        .background(Color(.systemGray6))
+        .cornerRadius(10)
+    }
+
+    private func warningBlock(title: String, lines: [String]) -> some View {
+        VStack(alignment: .leading, spacing: 4) {
+            Text(title)
+                .font(.caption)
+                .foregroundColor(.secondary)
+            ForEach(lines, id: \.self) { line in
+                Text(line)
+                    .font(.footnote)
+                    .foregroundColor(.secondary)
+                    .frame(maxWidth: .infinity, alignment: .leading)
+            }
+        }
+        .padding(.vertical, 6)
+    }
+
+    private func currentMessageTemplate() -> MessageTemplate {
+        appState.pdfTemplate?.messageTemplate ?? .emptyDisabled
+    }
+
+    private func updateMessageTemplate(_ update: (inout MessageTemplate) -> Void) {
+        guard var template = appState.pdfTemplate else { return }
+        var mt = template.messageTemplate
+        update(&mt)
+        template.messageTemplate = mt
+        appState.saveTemplate(template)
+    }
+
+    private func syncTemplateEnabledState(_ template: inout MessageTemplate) {
+        if template.hasAnyContent {
+            if !template.isEnabled {
+                template.isEnabled = true
+            }
+        } else {
+            template.isEnabled = false
+        }
+    }
+
+    private func insertToken(_ token: String) {
+        let snippet = "{{\(token)}}"
+
+        switch messageTemplateFocus {
+        case .subject:
+            updateMessageTemplate { mt in
+                let clamped = Self.clamp(range: messageSubjectSelection, in: mt.subject)
+                let ns = mt.subject as NSString
+                mt.subject = ns.replacingCharacters(in: clamped, with: snippet)
+                messageSubjectSelection = NSRange(location: clamped.location + (snippet as NSString).length, length: 0)
+                mt.lastEdited = Date()
+                syncTemplateEnabledState(&mt)
+            }
+        case .body:
+            updateMessageTemplate { mt in
+                let clamped = Self.clamp(range: messageBodySelection, in: mt.body)
+                let ns = mt.body as NSString
+                mt.body = ns.replacingCharacters(in: clamped, with: snippet)
+                messageBodySelection = NSRange(location: clamped.location + (snippet as NSString).length, length: 0)
+                mt.lastEdited = Date()
+                syncTemplateEnabledState(&mt)
+            }
+        default:
+            updateMessageTemplate { mt in
+                let clamped = Self.clamp(range: messageBodySelection, in: mt.body)
+                let ns = mt.body as NSString
+                mt.body = ns.replacingCharacters(in: clamped, with: snippet)
+                messageBodySelection = NSRange(location: clamped.location + (snippet as NSString).length, length: 0)
+                mt.lastEdited = Date()
+                syncTemplateEnabledState(&mt)
+            }
+        }
+    }
+
+    private func appendToken(_ token: String, to text: String) -> String {
+        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
+        if trimmed.isEmpty {
+            return token
+        }
+
+        if text.hasSuffix("\n") {
+            return text + token
+        }
+
+        return text + " " + token
+    }
+
+    private func previewRecipientForTemplate() -> Recipient? {
+        if let id = previewRecipientID, let found = selectedRecipients.first(where: { $0.id == id }) {
+            return found
+        }
+        return selectedRecipients.first ?? appState.recipients.first
+    }
+
+    private func resolvedMessageTokenValues(for recipient: Recipient, messageTemplate: MessageTemplate, csvTokens: [CSVTokenDescriptor]) -> [String: String] {
+        var values: [String: String] = [:]
+
+        values["recipient_name"] = displayName(for: recipient)
+        values["recipient_email"] = resolvedEmail(for: recipient)
+
+        for item in csvTokens {
+            let boundHeader = messageTemplate.tokenBindings[item.token]?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
+            let headerToUse = boundHeader.isEmpty ? item.header : boundHeader
+            values[item.token] = recipient.value(forKey: headerToUse)?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
+        }
+
+        values["packet_title"] = (appState.pdfTemplate?.name ?? "").trimmingCharacters(in: .whitespacesAndNewlines)
+
+        let formatter = DateFormatter()
+        formatter.locale = Locale.current
+        formatter.timeZone = TimeZone.current
+        formatter.dateStyle = .short
+        formatter.timeStyle = .none
+        values["date"] = formatter.string(from: Date())
+
+        values["sender_name"] = appState.senderName.trimmingCharacters(in: .whitespacesAndNewlines)
+        values["sender_email"] = appState.senderEmail.trimmingCharacters(in: .whitespacesAndNewlines)
+
+        return values
+    }
+
+    private func requiredMessageTemplateIssues(
+        referencedTokens: Set<String>,
+        hasCSV: Bool,
+        headers: [String],
+        csvTokenSet: Set<String>,
+        messageTemplate: MessageTemplate
+    ) -> [String] {
+        var issues: [String] = []
+
+        let referencedCSV = referencedTokens.intersection(csvTokenSet)
+        if !referencedCSV.isEmpty, !hasCSV {
+            issues.append("Import a CSV to resolve tokens derived from CSV headers.")
+        }
+
+        return issues
+    }
+
+    private func exportGeneratedBundle() {
+        guard let template = appState.pdfTemplate else { return }
+        guard !generatedPDFs.isEmpty else { return }
+
+        let messageTemplate = template.messageTemplate
+        let shouldWriteMessages = messageTemplate.isEnabled && messageTemplate.hasAnyContent
+
+        let headers = appState.csvImport?.headers ?? []
+        let csvTokens = csvTokenCatalog(headers: headers)
+        let csvTokenSet = Set(csvTokens.map { $0.token })
+        let allowedTokens = MessageTemplateRenderer.systemTokens.union(csvTokenSet)
+
+        let fm = FileManager.default
+        let tempRoot = fm.temporaryDirectory
+
+        let dateFormatter = DateFormatter()
+        dateFormatter.locale = Locale(identifier: "en_US_POSIX")
+        dateFormatter.timeZone = TimeZone.current
+        dateFormatter.dateFormat = "yyyy-MM-dd_HHmmss"
+
+        let rootName = "Export_\(safeFileComponent(template.name))_\(dateFormatter.string(from: Date()))"
+        let rootURL = tempRoot.appendingPathComponent(rootName, isDirectory: true)
+
+        do {
+            if fm.fileExists(atPath: rootURL.path) {
+                try fm.removeItem(at: rootURL)
+            }
+            try fm.createDirectory(at: rootURL, withIntermediateDirectories: true)
+        } catch {
+            exportErrorMessage = "Could not create export folder."
+            showingExportErrorAlert = true
+            return
+        }
+
+        var summaryLines: [String] = []
+        summaryLines.append("recipient_name,recipient_email,pdf_path,message_path")
+
+        for item in generatedPDFs {
+            let recipient = item.recipient
+            let folderComponent = safeFileComponent(displayName(for: recipient))
+            let shortID = String(recipient.id.uuidString.prefix(8))
+            let recipientFolderName = "\(folderComponent.isEmpty ? "Recipient" : folderComponent)_\(shortID)"
+            let recipientFolderURL = rootURL.appendingPathComponent(recipientFolderName, isDirectory: true)
+
+            do {
+                try fm.createDirectory(at: recipientFolderURL, withIntermediateDirectories: true)
+            } catch {
+                exportErrorMessage = "Could not create a recipient folder."
+                showingExportErrorAlert = true
+                return
+            }
+
+            let pdfURL = recipientFolderURL.appendingPathComponent("Packet.pdf")
+            do {
+                try item.pdfData.write(to: pdfURL, options: [.atomic])
+            } catch {
+                exportErrorMessage = "Could not write Packet.pdf."
+                showingExportErrorAlert = true
+                return
+            }
+
+            var messageRelativePath = ""
+            if shouldWriteMessages {
+                let values = resolvedMessageTokenValues(for: recipient, messageTemplate: messageTemplate, csvTokens: csvTokens)
+                let result = MessageTemplateRenderer.render(template: messageTemplate, allowedTokens: allowedTokens, resolvedValues: values)
+                let messageText = "Subject: \(result.subject)\n\n\(result.body)"
+
+                let messageURL = recipientFolderURL.appendingPathComponent("Message.txt")
+                do {
+                    try messageText.write(to: messageURL, atomically: true, encoding: .utf8)
+                    messageRelativePath = "\(recipientFolderName)/Message.txt"
+                } catch {
+                    exportErrorMessage = "Could not write Message.txt."
+                    showingExportErrorAlert = true
+                    return
+                }
+            }
+
+            let recipientNameCSV = escapeCSVField(displayName(for: recipient))
+            let recipientEmailCSV = escapeCSVField(resolvedEmail(for: recipient))
+            let pdfRelativePath = "\(recipientFolderName)/Packet.pdf"
+            let pdfPathCSV = escapeCSVField(pdfRelativePath)
+            let messagePathCSV = escapeCSVField(messageRelativePath)
+            summaryLines.append("\(recipientNameCSV),\(recipientEmailCSV),\(pdfPathCSV),\(messagePathCSV)")
+        }
+
+        let summaryCSV = summaryLines.joined(separator: "\n") + "\n"
+        let summaryURL = rootURL.appendingPathComponent("Summary.csv")
+        do {
+            try summaryCSV.write(to: summaryURL, atomically: true, encoding: .utf8)
+        } catch {
+            // Summary is optional; ignore failures.
+        }
+
+        currentExportBundle = ExportBundle(url: rootURL)
+    }
+
+    private func csvTokenCatalog(headers: [String]) -> [CSVTokenDescriptor] {
+        var used: [String: Int] = [:]
+        var out: [CSVTokenDescriptor] = []
+        out.reserveCapacity(headers.count)
+
+        for header in headers {
+            let base = normalizeHeaderToToken(header)
+            let count = (used[base] ?? 0) + 1
+            used[base] = count
+            let token = count == 1 ? base : "\(base)_\(count)"
+            out.append(CSVTokenDescriptor(token: token, header: header))
+        }
+        return out
+    }
+
+    private func normalizeHeaderToToken(_ header: String) -> String {
+        let trimmed = header.trimmingCharacters(in: .whitespacesAndNewlines)
+        let tokens = NormalizedName.from(trimmed).tokens
+        if !tokens.isEmpty {
+            return tokens.joined(separator: "_")
+        }
+
+        // Fallback: keep only lowercase alphanumerics, join chunks with underscores.
+        let lower = trimmed.lowercased()
+        let parts = lower
+            .components(separatedBy: CharacterSet.alphanumerics.inverted)
+            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
+            .filter { !$0.isEmpty }
+        let joined = parts.joined(separator: "_")
+        return joined.isEmpty ? "column" : joined
+    }
+
+    private func escapeCSVField(_ field: String) -> String {
+        if field.contains(",") || field.contains("\"") || field.contains("\n") || field.contains("\r") {
+            let escapedField = field.replacingOccurrences(of: "\"", with: "\"\"")
+            return "\"\(escapedField)\""
+        }
+        return field
+    }
+
     private func attemptGenerate() {
         if selectedRecipientIDs.isEmpty {
             showingNoRecipientsSelectedAlert = true
@@ -374,8 +1067,10 @@ struct GenerateView: View {
             return
         }
 
-        // Hide the recipient list after starting generation to reduce screen clutter.
+        // Hide the recipient list + Message Template panel after starting generation to reduce screen clutter.
         isRecipientListExpanded = false
+        isMessageTemplateExpanded = false
+        messageTemplateFocus = nil
         generatePDFs()
     }
     
@@ -434,16 +1129,44 @@ struct GenerateView: View {
             showingNoEmailForRowAlert = true
             return
         }
+
+        let fallbackSubject = "\(templateName) PDF"
+        let subjectAndBody = resolvedMailSubjectAndBody(for: item.recipient, fallbackSubject: fallbackSubject)
+
         let mailItem = MailItem(
             recipientName: displayName(for: item.recipient),
             recipientEmail: email,
             templateName: templateName,
+            subject: subjectAndBody.subject,
+            body: subjectAndBody.body,
             fileName: fileName,
             pdfData: item.pdfData
         )
 
         currentMailItem = mailItem
     }
+
+    private func resolvedMailSubjectAndBody(for recipient: Recipient, fallbackSubject: String) -> (subject: String, body: String) {
+        guard let template = appState.pdfTemplate else {
+            return (fallbackSubject, "")
+        }
+
+        let mt = template.messageTemplate
+        guard mt.isEnabled, mt.hasAnyContent else {
+            return (fallbackSubject, "")
+        }
+
+        let headers = appState.csvImport?.headers ?? []
+        let csvTokens = csvTokenCatalog(headers: headers)
+        let csvTokenSet = Set(csvTokens.map { $0.token })
+        let allowedTokens = MessageTemplateRenderer.systemTokens.union(csvTokenSet)
+
+        let values = resolvedMessageTokenValues(for: recipient, messageTemplate: mt, csvTokens: csvTokens)
+        let result = MessageTemplateRenderer.render(template: mt, allowedTokens: allowedTokens, resolvedValues: values)
+
+        let subject = result.subject.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? fallbackSubject : result.subject
+        return (subject, result.body)
+    }
     
     private func logSend(recipientName: String, templateName: String, fileName: String, method: SendLog.SendMethod) {
         let log = SendLog(
@@ -670,11 +1393,18 @@ struct ShareItem: Identifiable {
     let fileName: String
 }
 
+struct ExportBundle: Identifiable {
+    let id = UUID()
+    let url: URL
+}
+
 struct MailItem: Identifiable {
     let id = UUID()
     let recipientName: String
     let recipientEmail: String
     let templateName: String
+    let subject: String
+    let body: String
     let fileName: String
     let pdfData: Data
 }
diff --git a/PDFPacketBuilder/Views/HowToUseView.swift b/PDFPacketBuilder/Views/HowToUseView.swift
new file mode 100644
index 0000000..e9b2aeb
--- /dev/null
+++ b/PDFPacketBuilder/Views/HowToUseView.swift
@@ -0,0 +1,86 @@
+//
+//  HowToUseView.swift
+//  PDFPacketBuilder
+//
+
+import SwiftUI
+
+struct HowToUseView: View {
+    var body: some View {
+        ScrollView {
+            VStack(alignment: .leading, spacing: 16) {
+                Group {
+                    Text("Quick Start")
+                        .font(.title2)
+                        .fontWeight(.semibold)
+
+                    Text("Build and send personalized, fillable PDFs from a CSV list. No backend.")
+                        .foregroundColor(.secondary)
+                }
+
+                Group {
+                    Text("1) Import a template")
+                        .font(.headline)
+                    Text("Go to Template and import a fillable PDF (AcroForm text fields).")
+                        .foregroundColor(.secondary)
+                }
+
+                Group {
+                    Text("2) Add recipients")
+                        .font(.headline)
+                    Text("Go to Recipients and import a CSV or add recipients manually.")
+                        .foregroundColor(.secondary)
+                }
+
+                Group {
+                    Text("3) Map fields")
+                        .font(.headline)
+                    Text("Go to Map and connect PDF fields to recipient data. Mapping is always manual.")
+                        .foregroundColor(.secondary)
+                }
+
+                Group {
+                    Text("4) Generate")
+                        .font(.headline)
+                    Text("Go to Generate, select recipients, then tap Generate PDFs.")
+                        .foregroundColor(.secondary)
+
+                    Text("Optional: Enable Message Template to create a per-recipient subject/body using tokens like {{recipient_name}} and CSV-header tokens.")
+                        .foregroundColor(.secondary)
+                }
+
+                Group {
+                    Text("5) Share or Mail")
+                        .font(.headline)
+                    Text("Use Share to hand off the generated PDF to another app, or Mail to open the Mail composer with the PDF attached.")
+                        .foregroundColor(.secondary)
+
+                    Text("Logs are recorded only after a confirmed delivery action:")
+                        .font(.subheadline)
+                    VStack(alignment: .leading, spacing: 6) {
+                        Text("• Share: logged only when the share completes")
+                        Text("• Mail: logged only when Mail reports Sent")
+                    }
+                    .foregroundColor(.secondary)
+                }
+
+                Group {
+                    Text("6) Logs and export")
+                        .font(.headline)
+                    Text("Go to Logs to view history and export as CSV.")
+                        .foregroundColor(.secondary)
+                }
+            }
+            .padding()
+        }
+        .navigationTitle("How to Use")
+    }
+}
+
+struct HowToUseView_Previews: PreviewProvider {
+    static var previews: some View {
+        NavigationView {
+            HowToUseView()
+        }
+    }
+}
diff --git a/PDFPacketBuilder/Views/QuickStartView.swift b/PDFPacketBuilder/Views/QuickStartView.swift
new file mode 100644
index 0000000..edb61ff
--- /dev/null
+++ b/PDFPacketBuilder/Views/QuickStartView.swift
@@ -0,0 +1,60 @@
+//
+//  QuickStartView.swift
+//  PDFPacketBuilder
+//
+
+import SwiftUI
+
+struct QuickStartView: View {
+    @AppStorage("showQuickStartOnLaunch") private var showQuickStartOnLaunch = true
+
+    @Environment(\.dismiss) private var dismiss
+
+    var body: some View {
+        NavigationView {
+            ScrollView {
+                VStack(alignment: .leading, spacing: 14) {
+                    Text("Welcome")
+                        .font(.title2)
+                        .fontWeight(.semibold)
+
+                    Text("This app builds personalized PDFs from a fillable template and a recipient list.")
+                        .foregroundColor(.secondary)
+
+                    VStack(alignment: .leading, spacing: 10) {
+                        Text("What to do")
+                            .font(.headline)
+
+                        VStack(alignment: .leading, spacing: 6) {
+                            Text("1. Import a fillable PDF template")
+                            Text("2. Import a CSV or add recipients")
+                            Text("3. Map PDF fields")
+                            Text("4. Generate PDFs")
+                            Text("5. Share or Mail")
+                        }
+                        .foregroundColor(.secondary)
+                    }
+
+                    Toggle("Show on startup", isOn: $showQuickStartOnLaunch)
+
+                    NavigationLink("How to Use", destination: HowToUseView())
+                }
+                .padding()
+            }
+            .navigationTitle("Quick Start")
+            .toolbar {
+                ToolbarItem(placement: .confirmationAction) {
+                    Button("Done") {
+                        dismiss()
+                    }
+                }
+            }
+        }
+    }
+}
+
+struct QuickStartView_Previews: PreviewProvider {
+    static var previews: some View {
+        QuickStartView()
+    }
+}
diff --git a/PDFPacketBuilder/Views/SettingsView.swift b/PDFPacketBuilder/Views/SettingsView.swift
index c4dc38a..f190c8a 100644
--- a/PDFPacketBuilder/Views/SettingsView.swift
+++ b/PDFPacketBuilder/Views/SettingsView.swift
@@ -10,10 +10,31 @@ struct SettingsView: View {
     @EnvironmentObject var iapManager: IAPManager
     @State private var showingPurchaseSheet = false
     @State private var isRestoring = false
+    @State private var showingQuickStart = false
 
 #if DEBUG
     @State private var debugForceFreeTier = false
+    @AppStorage("debug_useMailSimulator") private var debugUseMailSimulator = false
 #endif
+
+    private var appVersionDisplay: String {
+        let short = Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String
+        let build = Bundle.main.object(forInfoDictionaryKey: "CFBundleVersion") as? String
+
+        let s = (short ?? "").trimmingCharacters(in: .whitespacesAndNewlines)
+        let b = (build ?? "").trimmingCharacters(in: .whitespacesAndNewlines)
+
+        if !s.isEmpty, !b.isEmpty {
+            return "\(s) (\(b))"
+        }
+        if !s.isEmpty {
+            return s
+        }
+        if !b.isEmpty {
+            return "Build \(b)"
+        }
+        return ""
+    }
     
     var body: some View {
         NavigationView {
@@ -33,6 +54,45 @@ struct SettingsView: View {
                     }
                 }
 
+                Section(header: Text("Sender")) {
+                    TextField(
+                        "Sender name",
+                        text: Binding(
+                            get: { appState.senderName },
+                            set: { newValue in
+                                appState.saveSenderName(newValue)
+                            }
+                        )
+                    )
+                    .textInputAutocapitalization(.words)
+
+                    TextField(
+                        "Sender email",
+                        text: Binding(
+                            get: { appState.senderEmail },
+                            set: { newValue in
+                                appState.saveSenderEmail(newValue)
+                            }
+                        )
+                    )
+                    .textInputAutocapitalization(.never)
+                    .keyboardType(.emailAddress)
+                }
+
+                Section(header: Text("Help")) {
+                    NavigationLink {
+                        HowToUseView()
+                    } label: {
+                        Label("How to Use", systemImage: "questionmark.circle")
+                    }
+
+                    Button {
+                        showingQuickStart = true
+                    } label: {
+                        Label("Quick Start", systemImage: "sparkles")
+                    }
+                }
+
 #if DEBUG
                 Section(header: Text("Testing")) {
                     Toggle("Simulate Free Tier", isOn: $debugForceFreeTier)
@@ -40,6 +100,12 @@ struct SettingsView: View {
                             iapManager.setDebugForceFreeTier(newValue)
                         }
 
+                    Toggle("Use Mail Simulator", isOn: $debugUseMailSimulator)
+
+                    Text("When enabled, the app will show an in-app mail simulator on devices that cannot send Mail (for example, the iOS Simulator).")
+                        .font(.caption)
+                        .foregroundColor(.secondary)
+
                     Text("Use this to test Free-tier limits even if the current Apple ID owns Pro. This does not change real App Store entitlements.")
                         .font(.caption)
                         .foregroundColor(.secondary)
@@ -116,7 +182,7 @@ struct SettingsView: View {
                     HStack {
                         Text("Version")
                         Spacer()
-                        Text("1.0.0")
+                        Text(appVersionDisplay)
                             .foregroundColor(.secondary)
                     }
                 }
@@ -125,6 +191,9 @@ struct SettingsView: View {
             .sheet(isPresented: $showingPurchaseSheet) {
                 PurchaseView()
             }
+            .sheet(isPresented: $showingQuickStart) {
+                QuickStartView()
+            }
 #if DEBUG
             .onAppear {
                 debugForceFreeTier = iapManager.debugForceFreeTierEnabled()
diff --git a/fastlane/Fastfile b/fastlane/Fastfile
index d2693ac..ff1eb04 100644
--- a/fastlane/Fastfile
+++ b/fastlane/Fastfile
@@ -32,6 +32,70 @@ rescue
 end
 
 platform :ios do
+  def git_output(cmd)
+    sh("cd '#{ROOT_DIR}' && #{cmd}", log: false).to_s
+  rescue
+    ""
+  end
+
+  def auto_testflight_changelog
+    max = env_value("TF_CHANGELOG_MAX").to_i
+    max = 12 if max <= 0
+
+    range = env_value("TF_CHANGELOG_RANGE")
+    if range.empty?
+      last_tag = git_output("git describe --tags --abbrev=0 2>/dev/null").strip
+      range = last_tag.empty? ? "HEAD~#{max}..HEAD" : "#{last_tag}..HEAD"
+    end
+
+    raw = git_output("git log #{range} --no-merges --pretty=format:%s")
+    subjects = raw
+      .lines
+      .map { |l| l.to_s.strip }
+      .reject { |l| l.empty? }
+      .reject { |l| l =~ /^merge\b/i }
+
+    subjects = subjects.first(max)
+
+    if subjects.empty?
+      fallback = git_output("git log -1 --pretty=format:%s").strip
+      subjects = [fallback] unless fallback.empty?
+    end
+
+    title = env_value("TF_CHANGELOG_TITLE")
+    title = Time.now.strftime("%Y-%m-%d") if title.empty?
+
+    bullets = subjects.map { |s| "- #{s}" }.join("\n")
+    notes = bullets.empty? ? title : "#{title}\n\n#{bullets}"
+    notes.to_s.strip
+  end
+
+  def read_testflight_changelog
+    from_env = env_value("TF_CHANGELOG")
+    return from_env unless from_env.empty?
+
+    path = File.join(ROOT_DIR, "fastlane", "testflight_changelog.txt")
+
+    # If a file exists and auto-generation isn't requested, use the file as-is.
+    auto = env_value("TF_AUTO_CHANGELOG")
+    if File.exist?(path) && auto != "1"
+      return File.read(path).to_s.strip
+    end
+
+    notes = auto_testflight_changelog
+
+    # Write a copy for easy review/editing before the next run (gitignored).
+    begin
+      File.write(path, notes + "\n") unless notes.to_s.strip.empty?
+    rescue => e
+      UI.important("Could not write #{path}: #{e}")
+    end
+
+    notes
+  rescue
+    ""
+  end
+
   private_lane :maybe_setup_api_key do
     key_id = env_value("ASC_KEY_ID")
     issuer_id = env_value("ASC_ISSUER_ID")
@@ -126,6 +190,10 @@ platform :ios do
       skip_waiting_for_build_processing: !should_wait
     }
 
+    # Always try to provide TestFlight release notes.
+    changelog = read_testflight_changelog
+    upload_args[:changelog] = changelog unless changelog.to_s.strip.empty?
+
     # Distribution to testers can require higher API key privileges than uploading.
     # Default to upload-only unless explicitly requested.
     distribute = ENV["TF_DISTRIBUTE"].to_s == "1" || groups.any?
